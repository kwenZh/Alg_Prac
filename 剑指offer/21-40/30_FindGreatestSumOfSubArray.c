/*
题目描述
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。
今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,
当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,
并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
*/

/*
这道题在寒假的时候做过，但是没有在网上测试，在牛客网一跑报了问题，仔细看了半天，
是自己逻辑上的一个漏洞，求和0并不是最小的 忽略掉了数组中全是负数的情况。
应该再加上一个要求 只允许一遍遍历数组。

思路：在一遍遍历数组的时候需要一个记录求和sum，一个记录当前和最大max，遍历数组的时候每走一步，求和变量是如何变化：
一开始求和和最大都让它是数组第一个元素，加上当前数组元素大于自己了的话就更新求和，不大于的话就保持不变，
加上你之后还不如没加你的时候大，那我就不更新求和变量。而当前和最大整个过程也很简单，
就是找到这一趟下来和的最大 如果找一个数组的最大值一样 出现了更大的和就更新max，
没有更大的就保持max不变。（寒假时候写的是默认都是0，这是不对的。）

不知道从什么时候开始
在什么东西上面都有个日期
秋刀鱼会过期
肉罐头会过期
寒假时写下的代码
今天突然就倒了
才发觉求和还有比0小的数字
*/
int FindGreatestSumOfSubArray(vector<int> array) {
  int sum = array[0];
  int max = array[0]; //这里的初始化很重要

  for(int i = 1; i < array.size(); i++) {
    sum = (sum + array[i]) > array[i] ? (sum + array[i]) : array[i];
    max = sum > max ? sum : max;
  }

  return max;
}

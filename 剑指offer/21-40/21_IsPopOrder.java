/*
题目描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，
序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
（注意：这两个序列的长度是相等的）

*/


import java.util.*;
/*
这种题以前在数据结构的选择题中常遇到，选择题做的时候都是去验证每个答案是否可以满足压栈弹栈。
这里实际编码解决刚开始没有什么思路。

通过分析错的出栈序列，4,3,5,1,2中错误的地方在1,2这是错误的关键，
1的出栈这里不行的 1此时是栈底的元素 上面还有元素2.

压栈的时候2在1的后面压栈，此时2都还没有出栈，1就要出栈显然是不合理。

可以借助另一个栈来判断完成，遍历压栈顺序，逐个把压栈顺序压入到栈中，压栈一个判断一个是否需要出栈，
如果此时栈顶元素等于出栈元素的第一个就出栈，最后只需要栈是否为空，是否出栈完了。
*/
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
      Stack<Integer> temp = new Stack<>();
		 int index = 0;

		 for(int i = 0; i < pushA.length; i++) {
			 temp.push(pushA[i]);
			 while(temp.size() > 0 && temp.peek() == popA[index]) {
				 temp.pop();
				 index++;
			 }
		 }

		 return temp.isEmpty();
    }
}
